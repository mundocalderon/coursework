Course 6 Notes

Sanity Check on Dev Environment - Checked out the course example and following the following build steps.

- I'm using rails 4.2.8, but example gemfile uses 4.2.6
  -going to change example gemfile to use 4.2.8
- running bundle update to get the right versions of gems
- running the bundle exec rake db:migrate returns Sprockets::Railtie::ManifestNeededError: Expected to find a manifest file in `app/assets/config/manifest.js`
- mkdir -p app/assets/config && echo '{}' > app/assets/config/manifest.js to create an empty manifest.js file.


Assignment 1 steps

- git init-iated a new directory and added a readme
-  rails-api new . -T -d postgresql - dash T is so that it skips testing templates and dash d to declare the db
- updates to database.yml file, using environment variables to auth into db
- run rake db:create, rake db:migrate, go through manifest fix, add to gemfile
- rails g rspec:install
- rails g rspec:request APIDevelopment
- Our Requirements so far: create a RDBMS-backed model, expose RDBMBS-backed API resource, create a MongoDB-backed model, expose MongoDB-backed API resource
- rails-api g scaffold City name --orm active_record --no-request-specs --no-routing-specs --no-controller-specs
- rails-api g scaffold State name --orm mongoid --no-request-specs --no-routing-specs --no-controller-specs
- Provision MongoDB 
- Provision Heroku servers
- deploy to heroku - I ran into an issue where deploying to heroku tries to precompile assets and there were assets gems not in the gemfile. I added the gems, bundled, and GIT COMMIT them, the push again and it worked.
- set the MONGO_URI to mongodb+srv://admin:<password>@clustercapstone-zl3dy.mongodb.net/test?retryWrites=true&w=majority
- mongodb atlas wants whitelisted IP addresses, so for heroku i used 0.0.0.0/0
- in config/environments/production.rb set config.force_ssl = true
-once i've fully deployed to staging, ill switch over to master 'git checkout master', and 'git merge staging-app' changes into master

Assignment 2 steps

- In preparing for production we make sure that assets ( js and css) are going to be compressed, production.rb file is updated to use uglifier and sass
- We'll need to add gems, asset directories and manifests, create assets initializer file, make server updates for precompiles, html page updates
- To properly have assets precompiled, run RAILS_ENV=production rake assets:precompile. Heroku assumes we precompile files to the /public directory, but if you don't specify the ENV, then uglifier doesn't uglify and it does development level precompiling and pushes that to heroku's public directory. How do I tell Heroku to precompile before deployment instead of precompiling locally and pushing those files.
(Web client development outside of rails asset pipeline uses node package manager, bower, and gulp tasks.)
- I created a git branch to go through install and init of npm, bower, and gulp tasks.
- Gulp Build Tasks - A build is made up of the most up to date source files, so the build tasks are mostly moving, sourcemapping, and grouping assets from different directories to one place that will serve up the latest build.
- Gulp branch was deployed to github pages, then we made edits to client to be able to be reployed from within the rails app on heroku and deployed that. once we had all 3 versions working, we merged the branches first into a temporary branch ap-external, and then into master.
- ui-router is tied to the <div ui-view></div>, so when we include it in our module, we define ui-router states and it is then displayed by the asset pipeline. we also have to register these javascript files in the manifest file.
- added our new module to access the cities resource, added file to manifest, and added API server location to app.config.js
(what the difference between Factory, Service, Provider? in the context of building a resource service to communicate with the RAILS API)
(Our factory returns a $resource that represents the collection of cities, instances of $resources represnts individual cities, $resouce is a part of ngResource )
(Angular Controller: Provides data and callbacks to the PAGE, accessible through the assigned 'controllerAs' - It primarily integrates the view with services, the services should contain any detailed code and controllers are integration code - new instances are created for each page creation, the injected services are singleton "helpers")
(whats the difference between Directive and Component?)
- added City service, controller, directive
- added a layout.css to start my styling
- filled out the city controller to perform CRUD operations
- deployed all 3 environments
- made CORS configurations
- branched out to assignment-2, removed all traces of other environments and am sticking to using the asset-pipeline, deployed to heroku and pushed branch to github.

Assignment 3

Testing
Gems / Tools
 Rspec - a domain specific for testing - use the shared context and shared examples. Use Ruby Modules,to build helper methods around some complex application interactions,like login and logout, so that we don't want to repeat everywhere. 
 Database Cleaner - to give us some transactional and truncation  db clean up strategies, to get db in a known state.
 Factory Girl - as objects get complex we can abstractify object creation in our tests.
 Faker Gem - to insert simulated data
 Capybary - to test web ui
 Selenium Driver - good for authoring, can see the interaction with the browser, keystrokes, button clicks, fields being filled in
 PhantomJS Driver with Poltergeist gem - have a nice headless solution, use that more for regression testing.  

Rspe Test types
 Unit - The item that is being tested is isolated, we use stubs and mocks to test that item specifically.
 Integration - the item that is being tested in the flow. Take a point in the application, go to the database and back. Takes longer to execute the tests and is limited in what can be tested, but gives us a more complete perspective of real world experience.
 Regression - will point out if we break something while we're implementing a feature down the road.

Model Specs on query scopes, facade methods, and relationships.
Request Specs evaluate APIs for functionality and payload concepts before building UI on top
Feature Specs will use Capybara to test the web ui and will use two drivers to do that.

Rspec tests
	Tips for DRYing examples(tests)
	 - before/afer blocks
	 - 'context' block refers to a example(test) group, 'it' blocks or 'scenario' blocks refer to individual examples(test)
	 - before(:all)/after(:all) blocks run once before/after all examples
	 - before(:each)/after(:each) blocks run before/after every example
	 - using '@attributes' allow for sharing/access between blocks
	 - 'let' blocks can replace the before blocks by instantiating their block whenever called, 'lazy instantiation'
   - The Capybara Gem is required to build feature specs. The two are hand in hand. The RackTest driver is the default web driver
      that Capybara is willing to use out of the box. This is the same driver that we did our API testing. And is also suitable for doing testing of static web pages. However, if you're going to render HTML using Javascript. You must bring in an additional driver that has support for Javascript. In order to do that, we must add metadata to the spec that indicates it must use a JavaScript capable driver. And the default JavaScript driver for Capybara is the Selenium-webdriver. 

	Drafting Tests
	 - Listing requirements only => don't add a block
	 - Expecting failures => use a pending block
	 - Bypasing tests => add an 'x' to the beginning of the line

   Capybara built-in waits (default wait = 2 secs)
   - find
   - have_content
   - have_css
   - within
   - find("ul li:nth-child(1) a").click
   - expect(page).to have_css("ul li:nth-child(1) a", text: @foos[0].name)
   No build-in wait
   - first
   - all
   - first("ul li").click
   - expect(first("ul li:nth-child(1) a").text).to eq(@foos[0].name)

  Steps
  - Made some configurations in prep for rspec testing. spec_helper including MongoidMatchers. config/env/test turned on/off the STDOUT logger. config/application reset the default specs generated by rails g. using mongoid-rspec gem for mongoid matchers. drafted first set of examples for active_record and mongoid resources.
  - we are using DatabaseCleaner to have better control of setting our testing environment, examples/tests will not be using transactions by default so we turn that setting off,adding gem, create a dbcleaners support file, and add the contexts to our spec files, make sure to include dependencies to spec_helper.rb
  .
  .
  .
  -started assignment off by cloning their repo, then making sure dev environment is working first by trying bundle install. Assignment repo uses json 1.8.3, which doesn't work with Ruby 2.4 and later, but ruby 2.3.8 is EOL, it requires openssl 1.0, homebrew removed the formula and only provides openssl1.1, the workaround is as follows:
    >brew install rbenv/tap/openssl@1.0
    >RUBY_CONFIGURE_OPTS="--with-openssl-dir=$(brew --prefix openssl@1.0)" rbenv install 2.3.8
    >rbenv local 2.3.8
    >rbenv rehash
    - you can install bundler now or rails which installs bundler, but if you try to install rails 4.2.6 it tries to use sprockets 4.0 which requires newer version of ruby. I instead installed 4.1.6, and then ran bundler.
    > gem install rails -v 4.1.6
    > bundle install
    - sqlite3 might fail, if it does try supplying install dir
    > gem install sqlite3 -v '1.3.12' -- --with-sqlite3-dir=/opt/local
    > bundle install
    > rake db:migrate
    
ExecJS::ProgramError: Unexpected token punc «(», expected punc «:» when running rake assets:precompile on production

>> require "Uglifier"
>>JS_PATH = "app/assets/javascripts/**/*.js"; Dir[JS_PATH].each do |file_name|  puts "\n#{file_name}" ; puts Uglifier.compile(File.read(file_name), harmony: true) end








